---
title: "Someone Said it Was Impossible: Hue Shift in Pixel Shader 2.0 (EasyPainter, Silverlight)"
date: 2010-02-09T20:30:00.0000000
draft: false
featured_image: ""
---

<p>I read somewhere online that Hue changes can't be done in pixel shader 2.0, due to limitation of 64 instructions per slot.</p>
<p>Here's the sample that proves otherwise:</p>
<p><a href="http://nokola.com/sources/HueShift.zip">Download source code</a></p>
<iframe src="/sample.aspx?xap=HueShift" width="640px" height="400px" style="border: 0px solid" frameborder="0"></iframe>
<p>Indeed the RGB-to-HSL-to-RGB conversion takes about 100 instructions in its typical implementation. PS 2.0 which is the shader model supported by Silverlight 3 only allows for 64 arithmetic instructions, as outlined in this <a title="Comparison Between Pixel Shaders on Wikipedia" href="http://en.wikipedia.org/wiki/Hlsl">comparison between pixel shaders on Wikipedia</a></p>
<p>How can we optimize it?</p>
<p>Optimizing pixel shader instruction slots is nice - in a typical C# world, you'd be adding if() statements to make your code run faster like this:</p>
<pre><strong>&nbsp;&nbsp;&nbsp; if ( HSV.y != 0 )</strong> {&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_h = HSV.x * 6;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_i = floor(var_h);&nbsp;&nbsp; // Or ... var_i = floor( var_h )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_1 = HSV.z * (1.0 - HSV.y);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_2 = HSV.z * (1.0 - HSV.y * (var_h-var_i));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_3 = HSV.z * (1.0 - HSV.y * (1-(var_h-var_i)));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (var_i == 0) { RGB = QUAD_REAL3(HSV.z, var_3, var_1); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 1) { RGB = QUAD_REAL3(var_2, HSV.z, var_1); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 2) { RGB = QUAD_REAL3(var_1, HSV.z, var_3); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 3) { RGB = QUAD_REAL3(var_1, var_2, HSV.z); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 4) { RGB = QUAD_REAL3(var_3, var_1, HSV.z); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { RGB = QUAD_REAL3(HSV.z, var_1, var_2); }<br />&nbsp;&nbsp; }</pre>
<p>Not with pixel shaders. If you look carefully at the bold if statement, removing it does not change the program logic. It just takes an extra instruction slot. In reality, I think the pixel shader code will run with the same speed with or without the if() (not 100% sure so correct me if needed).</p>
<p>With this knowledge, I decided to do these optimizations:</p>
<p>1. Instead of HSL-to-RGB, use HSV-to-RGB. The reference <a href="http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html">NVidia Shader Library</a> implementation (source code <a href="http://developer.download.nvidia.com/shaderlibrary/packages/post_RGB_from_HSV.fx.zip">here</a>)&nbsp;of HSV-RGB-HSV takes ~70 or so&nbsp;slots.</p>
<p>2. Combine the min_channel() and max_channel() functions into 1&nbsp;- saves a couple if() statements</p>
<p>3. Take out the if (x &lt; 0) (x += 1) checks in the RGB-HSV function, and execute them once instead of twice, after the hue is modified.</p>
<p>4. Remove the "obsolete" if()-s like the one above</p>
<p>I was very happy to see that it just fit in the 64-instruction slot of PS 2.0! Note that it hits the limit and more complex Hue stuff may need further optimizations! :) If you do so, please let me know! Anyway hue tricks that don't use more slots are OK.</p>
<p>Here's the complete Shazzam-friendly source of the .fx file (also included in the sample project source above).</p>
<pre>/// &lt;summary&gt;Hue shift&lt;/summary&gt;<br />/// &lt;minValue&gt;0&lt;/minValue&gt;<br />/// &lt;maxValue&gt;1&lt;/maxValue&gt;<br />/// &lt;defaultValue&gt;0&lt;/defaultValue&gt;<br />float HueShift : register(c0);</pre>
<pre>sampler2D Samp : register(S0);<br />#define QUAD_REAL float<br />#define QUAD_REAL3 float3</pre>
<pre>QUAD_REAL3 rgb_to_hsv_no_clip(QUAD_REAL3 RGB)<br />{<br />&nbsp;&nbsp;&nbsp; QUAD_REAL3 HSV;<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;float minChannel, maxChannel;<br />&nbsp;if (RGB.x &gt; RGB.y) {<br />&nbsp;&nbsp;maxChannel = RGB.x;<br />&nbsp;&nbsp;minChannel = RGB.y;<br />&nbsp;}<br />&nbsp;else {<br />&nbsp;&nbsp;maxChannel = RGB.y;<br />&nbsp;&nbsp;minChannel = RGB.x;<br />&nbsp;}<br />&nbsp;<br />&nbsp;if (RGB.z &gt; maxChannel) maxChannel = RGB.z;<br />&nbsp;if (RGB.z &lt; minChannel) minChannel = RGB.z;<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; HSV.xy = 0;<br />&nbsp;&nbsp;&nbsp; HSV.z = maxChannel;<br />&nbsp;&nbsp;&nbsp; QUAD_REAL delta = maxChannel - minChannel;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Delta RGB value <br />&nbsp;&nbsp;&nbsp; if (delta != 0) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If gray, leave H &amp; S at zero<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HSV.y = delta / HSV.z;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL3 delRGB;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delRGB = (HSV.zzz - RGB + 3*delta) / (6.0*delta);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( RGB.x == HSV.z ) HSV.x = delRGB.z - delRGB.y;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( RGB.y == HSV.z ) HSV.x = ( 1.0/3.0) + delRGB.x - delRGB.z;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( RGB.z == HSV.z ) HSV.x = ( 2.0/3.0) + delRGB.y - delRGB.x;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return (HSV);<br />}</pre>
<pre>QUAD_REAL3 hsv_to_rgb(QUAD_REAL3 HSV)<br />{<br />&nbsp;&nbsp;&nbsp; QUAD_REAL3 RGB = HSV.z;<br />&nbsp;&nbsp;&nbsp; //if ( HSV.y != 0 ) { // we don't really need this since it just adds an obsolete instruction slot<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_h = HSV.x * 6;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_i = floor(var_h);&nbsp;&nbsp; // Or ... var_i = floor( var_h )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_1 = HSV.z * (1.0 - HSV.y);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_2 = HSV.z * (1.0 - HSV.y * (var_h-var_i));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUAD_REAL var_3 = HSV.z * (1.0 - HSV.y * (1-(var_h-var_i)));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (var_i == 0) { RGB = QUAD_REAL3(HSV.z, var_3, var_1); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 1) { RGB = QUAD_REAL3(var_2, HSV.z, var_1); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 2) { RGB = QUAD_REAL3(var_1, HSV.z, var_3); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 3) { RGB = QUAD_REAL3(var_1, var_2, HSV.z); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (var_i == 4) { RGB = QUAD_REAL3(var_3, var_1, HSV.z); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { RGB = QUAD_REAL3(HSV.z, var_1, var_2); }<br />&nbsp;&nbsp; //}<br />&nbsp;&nbsp; return (RGB);<br />}</pre>
<pre>float4 main(float2 uv : TEXCOORD) : COLOR<br />{<br />&nbsp;float4 col = tex2D(Samp, uv);<br />&nbsp;float3 hsv = rgb_to_hsv_no_clip(col.xyz);<br />&nbsp;&nbsp;&nbsp; hsv.x+=HueShift;<br />&nbsp;&nbsp;&nbsp; //if ( hsv.x &lt; 0.0 ) { hsv.x += 1.0; }<br />&nbsp;&nbsp;&nbsp; if ( hsv.x &gt; 1.0 ) { hsv.x -= 1.0; }<br />&nbsp;&nbsp;&nbsp; return float4(hsv_to_rgb(hsv),col.w);<br />}</pre>
<pre>&nbsp;</pre>
<pre>btw, <a href="http://weblogs.asp.net/scottgu/archive/2010/02/08/vs-2010-net-4-release-candidate.aspx">Visual Studio 2010 RC</a> is out for MSDN subsribers (public tomorrow) and I'm going to publish all samples in VS 2010 from now on :)</pre>
<p>Hope you like it!</p>